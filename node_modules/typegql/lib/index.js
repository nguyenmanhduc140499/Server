'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var graphql = require('graphql');
var objectPath = require('object-path');
require('reflect-metadata');

const cache = new WeakMap();
function createCachedThunk(thunk) {
    return () => {
        if (cache.has(thunk)) {
            return cache.get(thunk);
        }
        const result = thunk();
        cache.set(thunk, result);
        return result;
    };
}

var COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/gm;
var DEFAULT_PARAMS = /=[^,]+/gm;
var FAT_ARROWS = /=>.*$/gm;
function getParameterNames(fn) {
    var code = fn
        .toString()
        .replace(COMMENTS, '')
        .replace(FAT_ARROWS, '')
        .replace(DEFAULT_PARAMS, '');
    var result = code
        .slice(code.indexOf('(') + 1, code.indexOf(')'))
        .match(/([^\s,]+)/g);
    return result === null ? [] : result;
}

function getClassWithAllParentClasses(target) {
    const result = [target];
    let currentNode = target;
    while (Object.getPrototypeOf(currentNode)) {
        const parent = Object.getPrototypeOf(currentNode);
        if (parent === Function.prototype)
            break;
        result.push(parent);
        currentNode = parent;
    }
    return result.reverse(); // reverse so we go from parents to children
}

function flattenPaths(paths) {
    return paths.reduce((accumulatedPath, nextPath) => {
        if (Array.isArray(nextPath)) {
            return [...accumulatedPath, ...nextPath.map(pathPart => `${pathPart}`)];
        }
        return [...accumulatedPath, `${nextPath}`];
    }, []);
}
class DeepWeakMap {
    constructor() {
        this.map = new WeakMap();
    }
    isEmpty(target) {
        return !Object.keys(this.getAll(target)).length;
    }
    getAll(target) {
        const { map } = this;
        if (!map.has(target)) {
            map.set(target, {});
        }
        return map.get(target);
    }
    set(target, path, value) {
        objectPath.set(this.getAll(target), path, value);
    }
    get(target, ...paths) {
        const path = flattenPaths(paths);
        return objectPath.get(this.getAll(target), path);
    }
    has(target, ...paths) {
        const path = flattenPaths(paths);
        return !!this.get(target, path);
    }
}

function isParsableScalar(input) {
    return [String, Number, Boolean].includes(input);
}
function parseNativeTypeToGraphQL(input) {
    if (input === String) {
        return graphql.GraphQLString;
    }
    if (input === Number) {
        return graphql.GraphQLFloat;
    }
    if (input === Boolean) {
        return graphql.GraphQLBoolean;
    }
}
function inferTypeByTarget(target, key) {
    if (!key) {
        return Reflect.getMetadata('design:type', target);
    }
    const returnType = Reflect.getMetadata('design:returntype', target, key);
    if (returnType) {
        return returnType;
    }
    const type = Reflect.getMetadata('design:type', target, key);
    return type;
}

/**
 *
 * @param input
 * @param allowThunk
 * @param preferInputType We want to be able to have single class used both for output and input type - thats why we need to be able to set resolve priority in different scenarios
 */
function resolveType(input, preferInputType = false, allowThunk = true) {
    if (graphql.isType(input)) {
        return input;
    }
    if (isParsableScalar(input)) {
        return parseNativeTypeToGraphQL(input);
    }
    if (Array.isArray(input)) {
        return resolveListType(input);
    }
    if (enumsRegistry.has(input)) {
        return enumsRegistry.get(input);
    }
    if (unionRegistry.has(input)) {
        return unionRegistry.get(input)();
    }
    if (preferInputType && inputObjectTypeRegistry.has(input)) {
        return compileInputObjectType(input);
    }
    if (objectTypeRegistry.has(input)) {
        return compileObjectType(input);
    }
    if (inputObjectTypeRegistry.has(input)) {
        return compileInputObjectType(input);
    }
    if (input === Promise) {
        return;
    }
    if (!allowThunk || typeof input !== 'function') {
        return;
    }
    try {
        return resolveType(input(), preferInputType, false);
    }
    catch (error) {
        return;
    }
}
function resolveListType(input, preferInputType = false) {
    if (input.length !== 1) {
        return;
    }
    const [itemType] = input;
    const resolvedItemType = resolveType(itemType, preferInputType);
    if (!resolvedItemType) {
        return;
    }
    return new graphql.GraphQLList(new graphql.GraphQLNonNull(resolvedItemType));
}
function resolveTypesList(types, preferInputType = false) {
    if (Array.isArray(types)) {
        return types.map(type => {
            return resolveType(type, preferInputType);
        });
    }
    return types().map(type => {
        return resolveType(type, preferInputType);
    });
}

function isObjectType(input) {
    return typeof input.getFields === 'function'; // TODO: More precise
}

const shownRegistry = new WeakMap();
function showDeprecationWarning(message, uniqueIdentifier, logger = console.log) {
    if (uniqueIdentifier && shownRegistry.has(uniqueIdentifier)) {
        return;
    }
    if (uniqueIdentifier) {
        shownRegistry.set(uniqueIdentifier, true);
    }
    logger(`@Deprecation warning: ${message}`);
}

const fieldsRegistry = new DeepWeakMap();

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

function __awaiter(thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

const injectorRegistry = new DeepWeakMap();

function Inject(resolver) {
    return (target, fieldName, argIndex) => {
        injectorRegistry.set(target.constructor, [fieldName, argIndex], resolver);
    };
}
const Context = Inject(({ context }) => {
    return context;
});
const Info = Inject(({ info }) => {
    return info;
});
const Source = Inject(({ source }) => {
    return source;
});

class BaseError extends Error {
}

class HookError extends BaseError {
    constructor(target, fieldName, msg) {
        const fullMsg = `@HookError ${target.name}.${fieldName}: ${msg}`;
        super(fullMsg);
        this.message = fullMsg;
    }
}

const fieldBeforeHooksRegistry = new DeepWeakMap();
const fieldAfterHooksRegistry = new DeepWeakMap();
function registerFieldBeforeHook(target, fieldName, hook) {
    if (!hook) {
        throw new HookError(target, fieldName, `Field @Before hook function must be supplied.`);
    }
    const currentHooks = fieldBeforeHooksRegistry.get(target, fieldName) || [];
    fieldBeforeHooksRegistry.set(target, fieldName, [hook, ...currentHooks]);
}
function registerFieldAfterHook(target, fieldName, hook) {
    if (!hook) {
        throw new HookError(target, fieldName, `Field @After hook function must be supplied.`);
    }
    const currentHooks = fieldAfterHooksRegistry.get(target, fieldName) || [];
    fieldAfterHooksRegistry.set(target, fieldName, [hook, ...currentHooks]);
}

function Before(hook) {
    return (targetInstance, fieldName) => {
        registerFieldBeforeHook(targetInstance.constructor, fieldName, hook);
    };
}
function After(hook) {
    return (targetInstance, fieldName) => {
        registerFieldAfterHook(targetInstance.constructor, fieldName, hook);
    };
}

const schemaRootsRegistry = new WeakMap();
const queryFieldsRegistry = new DeepWeakMap();
const mutationFieldsRegistry = new DeepWeakMap();

class SchemaRootError extends BaseError {
    constructor(target, msg) {
        const fullMsg = `@Schema ${target.name}: ${msg}`;
        super(fullMsg);
        this.message = fullMsg;
    }
}
class SchemaFieldError extends BaseError {
    constructor(target, fieldName, msg) {
        const fullMsg = `@Schema ${target.name}.${fieldName}: ${msg}`;
        super(fullMsg);
        this.message = fullMsg;
    }
}
class SchemaCompilationError extends BaseError {
    constructor(msg) {
        const fullMsg = `SchemaCompilationError: ${msg}`;
        super(fullMsg);
        this.message = fullMsg;
    }
}

function hasDuplicates(arr) {
    return (new Set(arr)).size !== arr.length;
}
function isSchemaRoot(base) {
    return schemaRootsRegistry.has(base);
}
function validateSchemaRoots(roots) {
    if (hasDuplicates(roots)) {
        throw new SchemaCompilationError(`At least one schema root is provided more than once in schema roots`);
    }
    for (let root of roots) {
        if (!schemaRootsRegistry.has(root)) {
            throw new SchemaRootError(root, `Schema root must be registered with @SchemaRoot`);
        }
    }
}
const schemaRootInstances = new WeakMap();
function getSchemaRootInstance(schemaRootClass) {
    if (!isSchemaRoot(schemaRootClass)) {
        return null;
    }
    if (schemaRootInstances.has(schemaRootClass)) {
        return schemaRootInstances.get(schemaRootClass);
    }
    const instance = new schemaRootClass();
    schemaRootInstances.set(schemaRootClass, instance);
    return instance;
}

function getAllRootFieldsFromRegistry(roots, registry, name) {
    const allRootFields = {};
    for (let root of roots) {
        const rootFields = registry.getAll(root);
        Object.keys(rootFields).forEach(fieldName => {
            const fieldConfigGetter = rootFields[fieldName];
            const fieldConfig = fieldConfigGetter();
            // throw error if root field with this name is already registered
            if (!!allRootFields[fieldName]) {
                throw new SchemaRootError(root, `Duplicate of root field name: '${fieldName}'. Seems this name is also used inside other schema root.`);
            }
            allRootFields[fieldName] = fieldConfig;
        });
    }
    const isEmpty = Object.keys(allRootFields).length < 1;
    if (isEmpty) {
        return null;
    }
    return new graphql.GraphQLObjectType({
        name,
        fields: allRootFields,
    });
}
function compileSchema(config) {
    const roots = typeof config === 'function' ? [config] : config.roots;
    if (typeof config === 'function') {
        showDeprecationWarning(`Passing schema root to compileSchema is deprecated. Use config object with 'roots' field. compileSchema(SchemaRoot) --> compileSchema({ roots: [SchemaRoot] })`, config);
    }
    validateSchemaRoots(roots);
    const query = getAllRootFieldsFromRegistry(roots, queryFieldsRegistry, 'Query');
    const mutation = getAllRootFieldsFromRegistry(roots, mutationFieldsRegistry, 'Mutation');
    if (!query) {
        throw new Error('At least one of schema roots must have @Query root field.');
    }
    return new graphql.GraphQLSchema({
        query: query || undefined,
        mutation: mutation || undefined,
    });
}

function validateRootSchemaField(targetInstance, fieldName) {
    if (!targetInstance[fieldName] &&
        !targetInstance.constructor.prototype[fieldName]) {
        throw new SchemaFieldError(targetInstance.constructor, fieldName, `Every root schema field must regular class function`);
    }
}
function requireSchemaRoot(target, fieldName) {
    if (schemaRootsRegistry.has(target)) {
        return;
    }
    throw new SchemaFieldError(target, fieldName, `Root field must be registered on class decorated with @Schema`);
}
function getFieldCompiler(target, fieldName) {
    const fieldCompiler = () => {
        requireSchemaRoot(target, fieldName);
        const compiledField = compileFieldConfig(target, fieldName);
        return compiledField;
    };
    return fieldCompiler;
}
// special fields
function Query(options) {
    return (targetInstance, fieldName) => {
        validateRootSchemaField(targetInstance, fieldName);
        Field(options)(targetInstance, fieldName);
        const fieldCompiler = getFieldCompiler(targetInstance.constructor, fieldName);
        queryFieldsRegistry.set(targetInstance.constructor, fieldName, fieldCompiler);
    };
}
function Mutation(options) {
    return (targetInstance, fieldName) => {
        validateRootSchemaField(targetInstance, fieldName);
        Field(options)(targetInstance, fieldName);
        const fieldCompiler = getFieldCompiler(targetInstance.constructor, fieldName);
        mutationFieldsRegistry.set(targetInstance.constructor, fieldName, fieldCompiler);
    };
}

function SchemaRoot(config = {}) {
    return target => {
        schemaRootsRegistry.set(target, config);
    };
}
function Schema(config = {}) {
    showDeprecationWarning('Use @SchemaRoot instead and compile like: compileSchema({ roots: [RootA, RootB] })', Schema);
    return SchemaRoot(config);
}

function performHooksExecution(hooks, source, args, context, info) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!hooks) {
            return;
        }
        // all hooks are executed in parrell instead of sequence. We wait for them all to be resolved before we continue
        return yield Promise.all(hooks.map(hook => {
            return hook({ source, args, context, info });
        }));
    });
}
function computeFinalArgs(func, { args, injectors, injectorToValueMapper }) {
    const paramNames = getParameterNames(func);
    return paramNames.map((paramName, index) => {
        if (args && args.hasOwnProperty(paramName)) {
            return args[paramName];
        }
        const injector = injectors[index];
        if (!injector) {
            return null;
        }
        return injectorToValueMapper(injector);
    });
}
function getFieldOfTarget(instance, prototype, fieldName) {
    if (!instance) {
        return prototype[fieldName];
    }
    const instanceField = instance[fieldName];
    if (instanceField !== undefined) {
        return instanceField;
    }
    return prototype[fieldName];
}
function compileFieldResolver(target, fieldName) {
    // const config = fieldsRegistry.get(target, fieldName);
    const injectors = injectorRegistry.getAll(target)[fieldName];
    const beforeHooks = fieldBeforeHooksRegistry.get(target, fieldName);
    const afterHooks = fieldAfterHooksRegistry.get(target, fieldName);
    return (source, args = null, context = null, info = null) => __awaiter(this, void 0, void 0, function* () {
        if (isSchemaRoot(target)) {
            source = getSchemaRootInstance(target);
        }
        yield performHooksExecution(beforeHooks, source, args, context, info);
        const instanceField = getFieldOfTarget(source, target.prototype, fieldName);
        if (typeof instanceField !== 'function') {
            yield performHooksExecution(afterHooks, source, args, context, info);
            return instanceField;
        }
        const instanceFieldFunc = instanceField;
        const params = computeFinalArgs(instanceFieldFunc, {
            args: args || {},
            injectors: injectors || {},
            injectorToValueMapper: injector => injector.apply(source, [{ source, args, context, info }]),
        });
        const result = yield instanceFieldFunc.apply(source, params);
        yield performHooksExecution(afterHooks, source, args, context, info); // TODO: Consider adding resolve return to hook callback
        return result;
    });
}

const argRegistry = new DeepWeakMap();

class ArgError extends BaseError {
    constructor(target, fieldName, argIndex, msg) {
        const paramNames = getParameterNames(target.prototype[fieldName]);
        const paramName = paramNames[argIndex];
        const fullMsg = `@Type ${target.name}.${fieldName}(${paramName} <-------): ${msg}`;
        super(fullMsg);
        this.message = fullMsg;
    }
}

const defaultArgOptions = {
    isNullable: false,
};

function compileInferedAndRegisterdArgs(infered, registeredArgs = {}) {
    const argsMerged = infered.map((inferedType, index) => {
        const registered = registeredArgs[index];
        if (registered && registered.type) {
            return registered.type;
        }
        return inferedType;
    });
    const resolvedArgs = argsMerged.map((rawType, index) => {
        return resolveType(rawType, true);
    });
    return resolvedArgs;
}
function validateArgs(target, fieldName, types) {
    types.forEach((argType, argIndex) => {
        const isInjectedArg = injectorRegistry.has(target, fieldName, argIndex);
        if (!isInjectedArg && !argType) {
            throw new ArgError(target, fieldName, argIndex, `Could not infer type of argument. Make sure to use native GraphQLInputType, native scalar like 'String' or class decorated with @InputObjectType`);
        }
        if (!isInjectedArg && !graphql.isInputType(argType)) {
            throw new ArgError(target, fieldName, argIndex, `Argument has incorrect type. Make sure to use native GraphQLInputType, native scalar like 'String' or class decorated with @InputObjectType`);
        }
        if (isInjectedArg && argRegistry.has(target, fieldName, argIndex)) {
            throw new ArgError(target, fieldName, argIndex, `Argument cannot be marked wiht both @Arg and @Inject or custom injector`);
        }
    });
    return true;
}
function enhanceType(originalType, isNullable) {
    let finalType = originalType;
    if (!isNullable) {
        finalType = new graphql.GraphQLNonNull(finalType);
    }
    return finalType;
}
function convertArgsArrayToArgsMap(target, fieldName, argsTypes, registeredArgs = {}) {
    const fieldDescriptor = Object.getOwnPropertyDescriptor(target.prototype, fieldName);
    // in case of getters, field arguments are not relevant
    if (fieldDescriptor.get) {
        return {};
    }
    const functionDefinition = target.prototype[fieldName];
    const argNames = getParameterNames(functionDefinition);
    if (!argNames || !argNames.length) {
        return {};
    }
    const argsMap = {};
    argNames.forEach((argName, index) => {
        const argConfig = registeredArgs[index] || Object.assign({}, defaultArgOptions);
        const argType = argsTypes[index];
        // don't publish args marked as auto Injected
        if (injectorRegistry.has(target, fieldName, index)) {
            return;
        }
        let finalType = enhanceType(argType, argConfig.isNullable);
        argsMap[argName] = {
            type: finalType,
            description: argConfig.description,
        };
    });
    return argsMap;
}
function compileFieldArgs(target, fieldName) {
    const registeredArgs = argRegistry.getAll(target)[fieldName];
    const inferedRawArgs = Reflect.getMetadata('design:paramtypes', target.prototype, fieldName);
    // There are no arguments
    if (!inferedRawArgs) {
        return {};
    }
    const argTypes = compileInferedAndRegisterdArgs(inferedRawArgs, registeredArgs);
    if (!validateArgs(target, fieldName, argTypes)) ;
    return convertArgsArrayToArgsMap(target, fieldName, argTypes, registeredArgs);
}

function Arg(options = {}) {
    return (target, fieldName, argIndex) => {
        const compiledOptions = Object.assign({}, defaultArgOptions, options);
        argRegistry.set(target.constructor, [fieldName, argIndex], compiledOptions);
    };
}

function resolveTypeOrThrow(type, target, fieldName) {
    const resolvedType = resolveType(type);
    if (!resolvedType) {
        throw new FieldError(target, fieldName, `Forced type is incorrect. Make sure to use either native graphql type or class that is registered with @Type decorator`);
    }
    return resolvedType;
}
function inferTypeOrThrow(target, fieldName) {
    const inferedType = inferTypeByTarget(target.prototype, fieldName);
    if (!inferedType) {
        throw new FieldError(target, fieldName, `Could not infer return type and no type is forced. In case of circular dependencies make sure to force types of instead of infering them.`);
    }
    return resolveType(inferedType);
}
function validateNotInferableField(target, fieldName) {
    const inferedType = inferTypeByTarget(target.prototype, fieldName);
    if (inferedType === Array) {
        throw new FieldError(target, fieldName, `Field returns list so it's required to explicitly set list item type. You can set list type like: @Field({ type: [ItemType] })`);
    }
    if (inferedType === Promise) {
        throw new FieldError(target, fieldName, `Field returns Promise so it's required to explicitly set resolved type as it's not possible to guess it. You can set resolved type like: @Field({ type: ItemType })`);
    }
    if (inferedType === Object) {
        throw new FieldError(target, fieldName, `It was not possible to guess type of this field. It might be because it returns Promise, Array etc. In such case it's needed to explicitly declare type of field like: @Field({ type: ItemType })`);
    }
    return true;
}

function resolveRegisteredOrInferedType(target, fieldName, forcedType) {
    if (forcedType) {
        return resolveTypeOrThrow(forcedType, target, fieldName);
    }
    return inferTypeOrThrow(target, fieldName);
}
function validateResolvedType(target, fieldName, type) {
    if (!graphql.isOutputType(type)) {
        throw new FieldError(target, fieldName, `Validation of type failed. Resolved type for @Field must be GraphQLOutputType.`);
    }
    return true;
}
function enhanceType$1(originalType, isNullable) {
    let finalType = originalType;
    if (!isNullable) {
        finalType = new graphql.GraphQLNonNull(finalType);
    }
    return finalType;
}
function isRootFieldOnNonRootBase(base, fieldName) {
    const isRoot = isSchemaRoot(base);
    if (isRoot) {
        return false;
    }
    if (mutationFieldsRegistry.has(base, fieldName)) {
        return true;
    }
    if (queryFieldsRegistry.has(base, fieldName)) {
        return true;
    }
    return false;
}

function compileFieldConfig(target, fieldName) {
    const { type, description, isNullable } = fieldsRegistry.get(target, fieldName);
    const args = compileFieldArgs(target, fieldName);
    const resolvedType = resolveRegisteredOrInferedType(target, fieldName, type);
    // if was not able to resolve type, try to show some helpful information about it
    if (!resolvedType && !validateNotInferableField(target, fieldName)) {
        return;
    }
    // show error about being not able to resolve field type
    if (!validateResolvedType(target, fieldName, resolvedType)) ;
    const finalType = enhanceType$1(resolvedType, isNullable);
    return {
        description,
        type: finalType,
        resolve: compileFieldResolver(target, fieldName),
        args,
    };
}
function getAllFields(target) {
    const fields = fieldsRegistry.getAll(target);
    const finalFieldsMap = {};
    Object.keys(fields).forEach(fieldName => {
        if (isRootFieldOnNonRootBase(target, fieldName)) {
            throw new FieldError(target, fieldName, `Given field is root field (@Query or @Mutation) not registered inside @Schema type. `);
        }
        const config = fieldsRegistry.get(target, fieldName);
        finalFieldsMap[config.name] = compileFieldConfig(target, fieldName);
    });
    return finalFieldsMap;
}
function compileAllFields(target) {
    const targetWithParents = getClassWithAllParentClasses(target);
    const finalFieldsMap = {};
    targetWithParents.forEach(targetLevel => {
        Object.assign(finalFieldsMap, getAllFields(targetLevel));
    });
    return finalFieldsMap;
}

class FieldError extends BaseError {
    constructor(target, fieldName, msg) {
        const fullMsg = `@ObjectType ${target.name}.${fieldName}: ${msg}`;
        super(fullMsg);
        this.message = fullMsg;
    }
}

function Field(options) {
    return (targetInstance, fieldName) => {
        const finalConfig = Object.assign({ property: fieldName, name: fieldName, isNullable: true }, options);
        fieldsRegistry.set(targetInstance.constructor, fieldName, Object.assign({}, finalConfig));
    };
}

const compileOutputTypeCache = new WeakMap();
function createTypeFieldsGetter(target) {
    const targetWithParents = getClassWithAllParentClasses(target);
    const hasFields = targetWithParents.some(ancestor => {
        return !fieldsRegistry.isEmpty(ancestor);
    });
    if (!hasFields) {
        throw new ObjectTypeError(target, `There are no fields inside this type.`);
    }
    return createCachedThunk(() => {
        return compileAllFields(target);
    });
}
function compileObjectTypeWithConfig(target, config) {
    if (compileOutputTypeCache.has(target)) {
        return compileOutputTypeCache.get(target);
    }
    const compiled = new graphql.GraphQLObjectType(Object.assign({}, config, { isTypeOf: value => value instanceof target, fields: createTypeFieldsGetter(target) }));
    compileOutputTypeCache.set(target, compiled);
    return compiled;
}
function compileObjectType(target) {
    if (!objectTypeRegistry.has(target)) {
        throw new ObjectTypeError(target, `Class is not registered. Make sure it's decorated with @ObjectType decorator`);
    }
    const compiler = objectTypeRegistry.get(target);
    return compiler();
}

const objectTypeRegistry = new WeakMap();

class ObjectTypeError extends BaseError {
    constructor(target, msg) {
        const fullMsg = `@ObjectType '${target.name}': ${msg}`;
        super(fullMsg);
        this.message = fullMsg;
    }
}

function ObjectType(options) {
    return (target) => {
        const config = Object.assign({ name: target.name }, options);
        const outputTypeCompiler = () => compileObjectTypeWithConfig(target, config);
        objectTypeRegistry.set(target, outputTypeCompiler);
    };
}

const inputFieldsRegistry = new DeepWeakMap();

function resolveTypeOrThrow$1(type, target, fieldName) {
    const resolvedType = resolveType(type, true);
    if (!resolvedType) {
        throw new InputFieldError(target, fieldName, `Forced type is incorrect. Make sure to use either native graphql type or class that is registered with @Type decorator`);
    }
    return resolvedType;
}
function inferTypeOrThrow$1(target, fieldName) {
    const inferedType = inferTypeByTarget(target.prototype, fieldName);
    if (!inferedType) {
        throw new InputFieldError(target, fieldName, `Could not infer return type and no type is forced. In case of circular dependencies make sure to force types of instead of infering them.`);
    }
    return resolveType(inferedType, true);
}

function getFinalInputFieldType(target, fieldName, forcedType) {
    if (forcedType) {
        return resolveTypeOrThrow$1(forcedType, target, fieldName);
    }
    return inferTypeOrThrow$1(target, fieldName);
}
function validateResolvedType$1(target, fieldName, type) {
    if (!graphql.isInputType(type)) {
        throw new InputFieldError(target, fieldName, `Validation of type failed. Resolved type for @Field must be GraphQLInputType.`);
    }
    return true;
}
function enhanceType$2(originalType, isNullable) {
    let finalType = originalType;
    if (!isNullable) {
        finalType = new graphql.GraphQLNonNull(finalType);
    }
    return finalType;
}
function compileInputFieldConfig(target, fieldName) {
    const { type, description, defaultValue, isNullable, } = inputFieldsRegistry.get(target, fieldName);
    const resolvedType = getFinalInputFieldType(target, fieldName, type);
    if (!validateResolvedType$1(target, fieldName, resolvedType)) ;
    const finalType = enhanceType$2(resolvedType, isNullable);
    return {
        description,
        defaultValue,
        type: finalType,
    };
}
function compileAllInputFieldsForSingleTarget(target) {
    const fields = inputFieldsRegistry.getAll(target);
    const finalFieldsMap = {};
    Object.keys(fields).forEach(fieldName => {
        const config = inputFieldsRegistry.get(target, fieldName);
        finalFieldsMap[config.name] = compileInputFieldConfig(target, fieldName);
    });
    return finalFieldsMap;
}
function compileAllInputFields(target) {
    const targetWithParents = getClassWithAllParentClasses(target);
    const finalFieldsMap = {};
    targetWithParents.forEach(targetLevel => {
        Object.assign(finalFieldsMap, compileAllInputFieldsForSingleTarget(targetLevel));
    });
    return finalFieldsMap;
}

class InputFieldError extends BaseError {
    constructor(target, fieldName, msg) {
        const fullMsg = `@InputField ${target.name}.${fieldName}: ${msg}`;
        super(fullMsg);
        this.message = fullMsg;
    }
}

function InputField(options) {
    return (targetInstance, fieldName) => {
        const finalConfig = Object.assign({ property: fieldName, name: fieldName }, options);
        inputFieldsRegistry.set(targetInstance.constructor, fieldName, finalConfig);
    };
}

const compileOutputTypeCache$1 = new WeakMap();
function createTypeInputFieldsGetter(target) {
    const targetWithParents = getClassWithAllParentClasses(target);
    const hasFields = targetWithParents.some(ancestor => {
        return !inputFieldsRegistry.isEmpty(ancestor);
    });
    if (!hasFields) {
        throw new InputObjectTypeError(target, `There are no fields inside this type.`);
    }
    return createCachedThunk(() => {
        return compileAllInputFields(target);
    });
}
function compileInputObjectTypeWithConfig(target, config) {
    if (compileOutputTypeCache$1.has(target)) {
        return compileOutputTypeCache$1.get(target);
    }
    const compiled = new graphql.GraphQLInputObjectType(Object.assign({}, config, { fields: createTypeInputFieldsGetter(target) }));
    compileOutputTypeCache$1.set(target, compiled);
    return compiled;
}
function compileInputObjectType(target) {
    if (!inputObjectTypeRegistry.has(target)) {
        throw new InputObjectTypeError(target, `Class is not registered. Make sure it's decorated with @InputObjectType decorator`);
    }
    const compiler = inputObjectTypeRegistry.get(target);
    return compiler();
}

const inputObjectTypeRegistry = new WeakMap();

class InputObjectTypeError extends BaseError {
    constructor(target, msg) {
        const fullMsg = `@InputObjectType '${target.name}': ${msg}`;
        super(fullMsg);
        this.message = fullMsg;
    }
}

function InputObjectType(options) {
    return (target) => {
        const config = Object.assign({ name: target.name }, options);
        const inputTypeCompiler = () => compileInputObjectTypeWithConfig(target, config);
        inputObjectTypeRegistry.set(target, inputTypeCompiler);
    };
}

class EnumError extends BaseError {
    constructor(name, msg) {
        const fullMsg = `Enum ${name}: ${msg}`;
        super(fullMsg);
        this.message = fullMsg;
    }
}

const enumsRegistry = new WeakMap();

function convertNativeEnumToGraphQLEnumValues(enumDef) {
    const valueConfigMap = {};
    Object.keys(enumDef).map(key => {
        if (!isNaN(key)) {
            return;
        }
        const value = enumDef[key];
        valueConfigMap[key] = {
            value,
        };
    });
    return valueConfigMap;
}

function registerEnum(enumDef, options) {
    if (typeof options === 'string') {
        options = { name: options };
    }
    const { name, description } = options;
    if (enumsRegistry.has(enumDef)) {
        throw new EnumError(name, `Enum is already registered`);
    }
    const values = convertNativeEnumToGraphQLEnumValues(enumDef);
    const enumType = new graphql.GraphQLEnumType({
        name,
        description,
        values,
    });
    enumsRegistry.set(enumDef, enumType);
    return enumType;
}

const unionRegistry = new WeakMap();

class UnionError extends BaseError {
    constructor(target, msg) {
        const fullMsg = `@Union '${target.name}': ${msg}`;
        super(fullMsg);
        this.message = fullMsg;
    }
}

const compileUnionCache = new WeakMap();
function getDefaultResolver(types) {
    return (value, context, info) => {
        for (let type of types) {
            if (type.isTypeOf && type.isTypeOf(value, context, info)) {
                return type;
            }
        }
    };
}
/**
 * Resolves type, and if needed, tries to resolve it using typegql-aware types
 */
function enhanceTypeResolver(originalResolver) {
    return (value, context, info) => {
        const rawResolvedType = originalResolver(value, context, info);
        return resolveType(rawResolvedType);
    };
}
function validateResolvedTypes(target, types) {
    for (let type of types) {
        if (!isObjectType(type)) {
            throw new UnionError(target, `Every union type must be of type GraphQLObjectType. '${type}' is not.`);
        }
    }
    return true;
}
function compileUnionType(target, config) {
    if (compileUnionCache.has(target)) {
        return compileUnionCache.get(target);
    }
    const { types, resolveTypes, name } = config;
    const resolvedTypes = resolveTypesList(types);
    if (!validateResolvedTypes(target, resolvedTypes)) ;
    const typeResolver = resolveTypes
        ? enhanceTypeResolver(resolveTypes)
        : getDefaultResolver(resolvedTypes);
    const compiled = new graphql.GraphQLUnionType({
        name,
        resolveType: typeResolver,
        types: resolvedTypes,
    });
    compileUnionCache.set(target, compiled);
    return compiled;
}

function Union(config) {
    return target => {
        unionRegistry.set(target, () => {
            return compileUnionType(target, Object.assign({ name: target.name }, config));
        });
    };
}

Object.defineProperty(exports, 'Float', {
  enumerable: true,
  get: function () {
    return graphql.GraphQLFloat;
  }
});
Object.defineProperty(exports, 'ID', {
  enumerable: true,
  get: function () {
    return graphql.GraphQLID;
  }
});
Object.defineProperty(exports, 'Int', {
  enumerable: true,
  get: function () {
    return graphql.GraphQLInt;
  }
});
exports.After = After;
exports.Arg = Arg;
exports.Before = Before;
exports.Context = Context;
exports.Field = Field;
exports.Info = Info;
exports.Inject = Inject;
exports.InputField = InputField;
exports.InputObjectType = InputObjectType;
exports.Mutation = Mutation;
exports.ObjectType = ObjectType;
exports.Query = Query;
exports.Schema = Schema;
exports.SchemaRoot = SchemaRoot;
exports.Source = Source;
exports.Union = Union;
exports.compileInputObjectType = compileInputObjectType;
exports.compileObjectType = compileObjectType;
exports.compileSchema = compileSchema;
exports.registerEnum = registerEnum;

{"code":"import { inferTypeByTarget, resolveType } from '~/services/utils';\r\nimport { FieldError } from '../index';\r\nexport function resolveTypeOrThrow(type, target, fieldName) {\r\n    const resolvedType = resolveType(type);\r\n    if (!resolvedType) {\r\n        throw new FieldError(target, fieldName, `Forced type is incorrect. Make sure to use either native graphql type or class that is registered with @Type decorator`);\r\n    }\r\n    return resolvedType;\r\n}\r\nexport function inferTypeOrThrow(target, fieldName) {\r\n    const inferedType = inferTypeByTarget(target.prototype, fieldName);\r\n    if (!inferedType) {\r\n        throw new FieldError(target, fieldName, `Could not infer return type and no type is forced. In case of circular dependencies make sure to force types of instead of infering them.`);\r\n    }\r\n    return resolveType(inferedType);\r\n}\r\nexport function validateNotInferableField(target, fieldName) {\r\n    const inferedType = inferTypeByTarget(target.prototype, fieldName);\r\n    if (inferedType === Array) {\r\n        throw new FieldError(target, fieldName, `Field returns list so it's required to explicitly set list item type. You can set list type like: @Field({ type: [ItemType] })`);\r\n    }\r\n    if (inferedType === Promise) {\r\n        throw new FieldError(target, fieldName, `Field returns Promise so it's required to explicitly set resolved type as it's not possible to guess it. You can set resolved type like: @Field({ type: ItemType })`);\r\n    }\r\n    if (inferedType === Object) {\r\n        throw new FieldError(target, fieldName, `It was not possible to guess type of this field. It might be because it returns Promise, Array etc. In such case it's needed to explicitly declare type of field like: @Field({ type: ItemType })`);\r\n    }\r\n    return true;\r\n}\r\n//# sourceMappingURL=fieldType.js.map","map":"{\"version\":3,\"file\":\"fieldType.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../../../src/domains/field/compiler/fieldType.ts\"],\"names\":[],\"mappings\":\"AACA,OAAO,EAAE,iBAAiB,EAAE,WAAW,EAAE,MAAM,kBAAkB,CAAC;AAClE,OAAO,EAAE,UAAU,EAAE,MAAM,UAAU,CAAC;AAEtC,MAAM,UAAU,kBAAkB,CAChC,IAAS,EACT,MAAgB,EAChB,SAAiB;IAEjB,MAAM,YAAY,GAAG,WAAW,CAAC,IAAI,CAAC,CAAC;IAEvC,IAAI,CAAC,YAAY,EAAE;QACjB,MAAM,IAAI,UAAU,CAClB,MAAM,EACN,SAAS,EACT,wHAAwH,CACzH,CAAC;KACH;IAED,OAAO,YAAY,CAAC;AACtB,CAAC;AAED,MAAM,UAAU,gBAAgB,CAC9B,MAAgB,EAChB,SAAiB;IAEjB,MAAM,WAAW,GAAG,iBAAiB,CAAC,MAAM,CAAC,SAAS,EAAE,SAAS,CAAC,CAAC;IACnE,IAAI,CAAC,WAAW,EAAE;QAChB,MAAM,IAAI,UAAU,CAClB,MAAM,EACN,SAAS,EACT,2IAA2I,CAC5I,CAAC;KACH;IACD,OAAO,WAAW,CAAC,WAAW,CAAC,CAAC;AAClC,CAAC;AAED,MAAM,UAAU,yBAAyB,CAAC,MAAgB,EAAE,SAAiB;IAC3E,MAAM,WAAW,GAAG,iBAAiB,CAAC,MAAM,CAAC,SAAS,EAAE,SAAS,CAAC,CAAC;IACnE,IAAI,WAAW,KAAK,KAAK,EAAE;QACzB,MAAM,IAAI,UAAU,CAClB,MAAM,EACN,SAAS,EACT,gIAAgI,CACjI,CAAC;KACH;IAED,IAAI,WAAW,KAAK,OAAO,EAAE;QAC3B,MAAM,IAAI,UAAU,CAClB,MAAM,EACN,SAAS,EACT,qKAAqK,CACtK,CAAC;KACH;IAED,IAAI,WAAW,KAAK,MAAM,EAAE;QAC1B,MAAM,IAAI,UAAU,CAClB,MAAM,EACN,SAAS,EACT,mMAAmM,CACpM,CAAC;KACH;IACD,OAAO,IAAI,CAAC;AACd,CAAC\"}","dts":{"name":"/Users/adampietrasiak/dev/oss/typegql/domains/field/compiler/fieldType.d.ts","writeByteOrderMark":false,"text":"import { GraphQLType } from 'graphql';\r\nexport declare function resolveTypeOrThrow(type: any, target: Function, fieldName: string): GraphQLType;\r\nexport declare function inferTypeOrThrow(target: Function, fieldName: string): GraphQLType;\r\nexport declare function validateNotInferableField(target: Function, fieldName: string): boolean;\r\n"}}

{"code":"import { isInputType, GraphQLNonNull, } from 'graphql';\r\nimport { resolveType, getParameterNames } from '~/services/utils';\r\nimport { injectorRegistry } from '~/domains/inject';\r\nimport { argRegistry } from './registry';\r\nimport { ArgError } from './error';\r\nimport { defaultArgOptions } from './options';\r\nfunction compileInferedAndRegisterdArgs(infered, registeredArgs = {}) {\r\n    const argsMerged = infered.map((inferedType, index) => {\r\n        const registered = registeredArgs[index];\r\n        if (registered && registered.type) {\r\n            return registered.type;\r\n        }\r\n        return inferedType;\r\n    });\r\n    const resolvedArgs = argsMerged.map((rawType, index) => {\r\n        return resolveType(rawType, true);\r\n    });\r\n    return resolvedArgs;\r\n}\r\nfunction validateArgs(target, fieldName, types) {\r\n    types.forEach((argType, argIndex) => {\r\n        const isInjectedArg = injectorRegistry.has(target, fieldName, argIndex);\r\n        if (!isInjectedArg && !argType) {\r\n            throw new ArgError(target, fieldName, argIndex, `Could not infer type of argument. Make sure to use native GraphQLInputType, native scalar like 'String' or class decorated with @InputObjectType`);\r\n        }\r\n        if (!isInjectedArg && !isInputType(argType)) {\r\n            throw new ArgError(target, fieldName, argIndex, `Argument has incorrect type. Make sure to use native GraphQLInputType, native scalar like 'String' or class decorated with @InputObjectType`);\r\n        }\r\n        if (isInjectedArg && argRegistry.has(target, fieldName, argIndex)) {\r\n            throw new ArgError(target, fieldName, argIndex, `Argument cannot be marked wiht both @Arg and @Inject or custom injector`);\r\n        }\r\n    });\r\n    return true;\r\n}\r\nfunction enhanceType(originalType, isNullable) {\r\n    let finalType = originalType;\r\n    if (!isNullable) {\r\n        finalType = new GraphQLNonNull(finalType);\r\n    }\r\n    return finalType;\r\n}\r\nfunction convertArgsArrayToArgsMap(target, fieldName, argsTypes, registeredArgs = {}) {\r\n    const fieldDescriptor = Object.getOwnPropertyDescriptor(target.prototype, fieldName);\r\n    // in case of getters, field arguments are not relevant\r\n    if (fieldDescriptor.get) {\r\n        return {};\r\n    }\r\n    const functionDefinition = target.prototype[fieldName];\r\n    const argNames = getParameterNames(functionDefinition);\r\n    if (!argNames || !argNames.length) {\r\n        return {};\r\n    }\r\n    const argsMap = {};\r\n    argNames.forEach((argName, index) => {\r\n        const argConfig = registeredArgs[index] || Object.assign({}, defaultArgOptions);\r\n        const argType = argsTypes[index];\r\n        // don't publish args marked as auto Injected\r\n        if (injectorRegistry.has(target, fieldName, index)) {\r\n            return;\r\n        }\r\n        let finalType = enhanceType(argType, argConfig.isNullable);\r\n        argsMap[argName] = {\r\n            type: finalType,\r\n            description: argConfig.description,\r\n        };\r\n    });\r\n    return argsMap;\r\n}\r\nexport function compileFieldArgs(target, fieldName) {\r\n    const registeredArgs = argRegistry.getAll(target)[fieldName];\r\n    const inferedRawArgs = Reflect.getMetadata('design:paramtypes', target.prototype, fieldName);\r\n    // There are no arguments\r\n    if (!inferedRawArgs) {\r\n        return {};\r\n    }\r\n    const argTypes = compileInferedAndRegisterdArgs(inferedRawArgs, registeredArgs);\r\n    if (!validateArgs(target, fieldName, argTypes)) {\r\n        return;\r\n    }\r\n    return convertArgsArrayToArgsMap(target, fieldName, argTypes, registeredArgs);\r\n}\r\n//# sourceMappingURL=compiler.js.map","map":"{\"version\":3,\"file\":\"compiler.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../../src/domains/arg/compiler.ts\"],\"names\":[],\"mappings\":\"AAAA,OAAO,EAIL,WAAW,EACX,cAAc,GACf,MAAM,SAAS,CAAC;AACjB,OAAO,EAAE,WAAW,EAAE,iBAAiB,EAAE,MAAM,kBAAkB,CAAC;AAClE,OAAO,EAAE,gBAAgB,EAAE,MAAM,kBAAkB,CAAC;AACpD,OAAO,EAAa,WAAW,EAAE,MAAM,YAAY,CAAC;AACpD,OAAO,EAAE,QAAQ,EAAE,MAAM,SAAS,CAAC;AACnC,OAAO,EAAE,iBAAiB,EAAE,MAAM,WAAW,CAAC;AAE9C,SAAS,8BAA8B,CACrC,OAAc,EACd,iBAA4B,EAAE;IAE9B,MAAM,UAAU,GAAG,OAAO,CAAC,GAAG,CAAC,CAAC,WAAW,EAAE,KAAK,EAAE,EAAE;QACpD,MAAM,UAAU,GAAG,cAAc,CAAC,KAAK,CAAC,CAAC;QACzC,IAAI,UAAU,IAAI,UAAU,CAAC,IAAI,EAAE;YACjC,OAAO,UAAU,CAAC,IAAI,CAAC;SACxB;QACD,OAAO,WAAW,CAAC;IACrB,CAAC,CAAC,CAAC;IAEH,MAAM,YAAY,GAAG,UAAU,CAAC,GAAG,CAAC,CAAC,OAAO,EAAE,KAAK,EAAE,EAAE;QACrD,OAAO,WAAW,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC;IACpC,CAAC,CAAC,CAAC;IAEH,OAAO,YAAY,CAAC;AACtB,CAAC;AAED,SAAS,YAAY,CACnB,MAAgB,EAChB,SAAiB,EACjB,KAAoB;IAEpB,KAAK,CAAC,OAAO,CAAC,CAAC,OAAO,EAAE,QAAQ,EAAE,EAAE;QAClC,MAAM,aAAa,GAAG,gBAAgB,CAAC,GAAG,CAAC,MAAM,EAAE,SAAS,EAAE,QAAQ,CAAC,CAAC;QAExE,IAAI,CAAC,aAAa,IAAI,CAAC,OAAO,EAAE;YAC9B,MAAM,IAAI,QAAQ,CAChB,MAAM,EACN,SAAS,EACT,QAAQ,EACR,kJAAkJ,CACnJ,CAAC;SACH;QAED,IAAI,CAAC,aAAa,IAAI,CAAC,WAAW,CAAC,OAAO,CAAC,EAAE;YAC3C,MAAM,IAAI,QAAQ,CAChB,MAAM,EACN,SAAS,EACT,QAAQ,EACR,6IAA6I,CAC9I,CAAC;SACH;QAED,IAAI,aAAa,IAAI,WAAW,CAAC,GAAG,CAAC,MAAM,EAAE,SAAS,EAAE,QAAQ,CAAC,EAAE;YACjE,MAAM,IAAI,QAAQ,CAChB,MAAM,EACN,SAAS,EACT,QAAQ,EACR,yEAAyE,CAC1E,CAAC;SACH;IACH,CAAC,CAAC,CAAC;IACH,OAAO,IAAI,CAAC;AACd,CAAC;AAED,SAAS,WAAW,CAAC,YAA8B,EAAE,UAAmB;IACtE,IAAI,SAAS,GAAG,YAAY,CAAC;IAC7B,IAAI,CAAC,UAAU,EAAE;QACf,SAAS,GAAG,IAAI,cAAc,CAAC,SAAS,CAAC,CAAC;KAC3C;IACD,OAAO,SAAS,CAAC;AACnB,CAAC;AAED,SAAS,yBAAyB,CAChC,MAAgB,EAChB,SAAiB,EACjB,SAA6B,EAC7B,iBAA4B,EAAE;IAE9B,MAAM,eAAe,GAAG,MAAM,CAAC,wBAAwB,CACrD,MAAM,CAAC,SAAS,EAChB,SAAS,CACV,CAAC;IAEF,uDAAuD;IACvD,IAAI,eAAe,CAAC,GAAG,EAAE;QACvB,OAAO,EAAE,CAAC;KACX;IAED,MAAM,kBAAkB,GAAG,MAAM,CAAC,SAAS,CAAC,SAAS,CAAC,CAAC;IACvD,MAAM,QAAQ,GAAG,iBAAiB,CAAC,kBAAkB,CAAC,CAAC;IAEvD,IAAI,CAAC,QAAQ,IAAI,CAAC,QAAQ,CAAC,MAAM,EAAE;QACjC,OAAO,EAAE,CAAC;KACX;IAED,MAAM,OAAO,GAAkC,EAAE,CAAC;IAClD,QAAQ,CAAC,OAAO,CAAC,CAAC,OAAO,EAAE,KAAK,EAAE,EAAE;QAClC,MAAM,SAAS,GAAG,cAAc,CAAC,KAAK,CAAC,sBAAS,iBAAiB,CAAE,CAAC;QACpE,MAAM,OAAO,GAAG,SAAS,CAAC,KAAK,CAAC,CAAC;QAEjC,6CAA6C;QAC7C,IAAI,gBAAgB,CAAC,GAAG,CAAC,MAAM,EAAE,SAAS,EAAE,KAAK,CAAC,EAAE;YAClD,OAAO;SACR;QAED,IAAI,SAAS,GAAG,WAAW,CAAC,OAAO,EAAE,SAAS,CAAC,UAAU,CAAC,CAAC;QAE3D,OAAO,CAAC,OAAO,CAAC,GAAG;YACjB,IAAI,EAAE,SAAS;YACf,WAAW,EAAE,SAAS,CAAC,WAAW;SACnC,CAAC;IACJ,CAAC,CAAC,CAAC;IACH,OAAO,OAAO,CAAC;AACjB,CAAC;AAED,MAAM,UAAU,gBAAgB,CAC9B,MAAgB,EAChB,SAAiB;IAEjB,MAAM,cAAc,GAAG,WAAW,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,SAAS,CAAC,CAAC;IAC7D,MAAM,cAAc,GAAG,OAAO,CAAC,WAAW,CACxC,mBAAmB,EACnB,MAAM,CAAC,SAAS,EAChB,SAAS,CACV,CAAC;IAEF,yBAAyB;IACzB,IAAI,CAAC,cAAc,EAAE;QACnB,OAAO,EAAE,CAAC;KACX;IAED,MAAM,QAAQ,GAAG,8BAA8B,CAC7C,cAAc,EACd,cAAc,CACf,CAAC;IAEF,IAAI,CAAC,YAAY,CAAC,MAAM,EAAE,SAAS,EAAE,QAAQ,CAAC,EAAE;QAC9C,OAAO;KACR;IAED,OAAO,yBAAyB,CAAC,MAAM,EAAE,SAAS,EAAE,QAAQ,EAAE,cAAc,CAAC,CAAC;AAChF,CAAC\"}","dts":{"name":"/Users/adampietrasiak/dev/oss/typegql/domains/arg/compiler.d.ts","writeByteOrderMark":false,"text":"import { GraphQLFieldConfigArgumentMap } from 'graphql';\r\nexport declare function compileFieldArgs(target: Function, fieldName: string): GraphQLFieldConfigArgumentMap;\r\n"}}

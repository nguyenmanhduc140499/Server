{"code":"import * as tslib_1 from \"tslib\";\r\nimport { injectorRegistry, } from '~/domains/inject';\r\nimport { fieldAfterHooksRegistry, fieldBeforeHooksRegistry, } from '~/domains/hooks';\r\nimport { getParameterNames } from '~/services/utils';\r\nimport { isSchemaRoot, getSchemaRootInstance } from '~/domains/schema';\r\nfunction performHooksExecution(hooks, source, args, context, info) {\r\n    return tslib_1.__awaiter(this, void 0, void 0, function* () {\r\n        if (!hooks) {\r\n            return;\r\n        }\r\n        // all hooks are executed in parrell instead of sequence. We wait for them all to be resolved before we continue\r\n        return yield Promise.all(hooks.map(hook => {\r\n            return hook({ source, args, context, info });\r\n        }));\r\n    });\r\n}\r\nfunction computeFinalArgs(func, { args, injectors, injectorToValueMapper }) {\r\n    const paramNames = getParameterNames(func);\r\n    return paramNames.map((paramName, index) => {\r\n        if (args && args.hasOwnProperty(paramName)) {\r\n            return args[paramName];\r\n        }\r\n        const injector = injectors[index];\r\n        if (!injector) {\r\n            return null;\r\n        }\r\n        return injectorToValueMapper(injector);\r\n    });\r\n}\r\nfunction getFieldOfTarget(instance, prototype, fieldName) {\r\n    if (!instance) {\r\n        return prototype[fieldName];\r\n    }\r\n    const instanceField = instance[fieldName];\r\n    if (instanceField !== undefined) {\r\n        return instanceField;\r\n    }\r\n    return prototype[fieldName];\r\n}\r\nexport function compileFieldResolver(target, fieldName) {\r\n    // const config = fieldsRegistry.get(target, fieldName);\r\n    const injectors = injectorRegistry.getAll(target)[fieldName];\r\n    const beforeHooks = fieldBeforeHooksRegistry.get(target, fieldName);\r\n    const afterHooks = fieldAfterHooksRegistry.get(target, fieldName);\r\n    return (source, args = null, context = null, info = null) => tslib_1.__awaiter(this, void 0, void 0, function* () {\r\n        if (isSchemaRoot(target)) {\r\n            source = getSchemaRootInstance(target);\r\n        }\r\n        yield performHooksExecution(beforeHooks, source, args, context, info);\r\n        const instanceField = getFieldOfTarget(source, target.prototype, fieldName);\r\n        if (typeof instanceField !== 'function') {\r\n            yield performHooksExecution(afterHooks, source, args, context, info);\r\n            return instanceField;\r\n        }\r\n        const instanceFieldFunc = instanceField;\r\n        const params = computeFinalArgs(instanceFieldFunc, {\r\n            args: args || {},\r\n            injectors: injectors || {},\r\n            injectorToValueMapper: injector => injector.apply(source, [{ source, args, context, info }]),\r\n        });\r\n        const result = yield instanceFieldFunc.apply(source, params);\r\n        yield performHooksExecution(afterHooks, source, args, context, info); // TODO: Consider adding resolve return to hook callback\r\n        return result;\r\n    });\r\n}\r\n//# sourceMappingURL=resolver.js.map","map":"{\"version\":3,\"file\":\"resolver.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../../../src/domains/field/compiler/resolver.ts\"],\"names\":[],\"mappings\":\";AACA,OAAO,EAGL,gBAAgB,GACjB,MAAM,kBAAkB,CAAC;AAC1B,OAAO,EACL,uBAAuB,EACvB,wBAAwB,GAEzB,MAAM,iBAAiB,CAAC;AACzB,OAAO,EAAE,iBAAiB,EAAE,MAAM,kBAAkB,CAAC;AAErD,OAAO,EAAE,YAAY,EAAE,qBAAqB,EAAE,MAAM,kBAAkB,CAAC;AAYvE,SAAe,qBAAqB,CAClC,KAAqB,EACrB,MAAW,EACX,IAAS,EACT,OAAY,EACZ,IAAS;;QAET,IAAI,CAAC,KAAK,EAAE;YACV,OAAO;SACR;QACD,gHAAgH;QAChH,OAAO,MAAM,OAAO,CAAC,GAAG,CACtB,KAAK,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE;YACf,OAAO,IAAI,CAAC,EAAE,MAAM,EAAE,IAAI,EAAE,OAAO,EAAE,IAAI,EAAE,CAAC,CAAC;QAC/C,CAAC,CAAC,CACH,CAAC;IACJ,CAAC;CAAA;AAED,SAAS,gBAAgB,CACvB,IAAc,EACd,EAAE,IAAI,EAAE,SAAS,EAAE,qBAAqB,EAAsB;IAE9D,MAAM,UAAU,GAAG,iBAAiB,CAAC,IAAI,CAAC,CAAC;IAC3C,OAAO,UAAU,CAAC,GAAG,CAAC,CAAC,SAAS,EAAE,KAAK,EAAE,EAAE;QACzC,IAAI,IAAI,IAAI,IAAI,CAAC,cAAc,CAAC,SAAS,CAAC,EAAE;YAC1C,OAAO,IAAI,CAAC,SAAS,CAAC,CAAC;SACxB;QAED,MAAM,QAAQ,GAAG,SAAS,CAAC,KAAK,CAAC,CAAC;QAElC,IAAI,CAAC,QAAQ,EAAE;YACb,OAAO,IAAI,CAAC;SACb;QAED,OAAO,qBAAqB,CAAC,QAAQ,CAAC,CAAC;IACzC,CAAC,CAAC,CAAC;AACL,CAAC;AAED,SAAS,gBAAgB,CAAC,QAAa,EAAE,SAAc,EAAE,SAAiB;IACxE,IAAI,CAAC,QAAQ,EAAE;QACb,OAAO,SAAS,CAAC,SAAS,CAAC,CAAC;KAC7B;IAED,MAAM,aAAa,GAAG,QAAQ,CAAC,SAAS,CAAC,CAAC;IAE1C,IAAI,aAAa,KAAK,SAAS,EAAE;QAC/B,OAAO,aAAa,CAAC;KACtB;IAED,OAAO,SAAS,CAAC,SAAS,CAAC,CAAC;AAC9B,CAAC;AAED,MAAM,UAAU,oBAAoB,CAClC,MAAgB,EAChB,SAAiB;IAEjB,wDAAwD;IACxD,MAAM,SAAS,GAAG,gBAAgB,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,SAAS,CAAC,CAAC;IAC7D,MAAM,WAAW,GAAG,wBAAwB,CAAC,GAAG,CAAC,MAAM,EAAE,SAAS,CAAC,CAAC;IACpE,MAAM,UAAU,GAAG,uBAAuB,CAAC,GAAG,CAAC,MAAM,EAAE,SAAS,CAAC,CAAC;IAElE,OAAO,CAAO,MAAW,EAAE,IAAI,GAAG,IAAI,EAAE,OAAO,GAAG,IAAI,EAAE,IAAI,GAAG,IAAI,EAAE,EAAE;QACrE,IAAI,YAAY,CAAC,MAAM,CAAC,EAAE;YACxB,MAAM,GAAG,qBAAqB,CAAC,MAAM,CAAC,CAAC;SACxC;QAED,MAAM,qBAAqB,CAAC,WAAW,EAAE,MAAM,EAAE,IAAI,EAAE,OAAO,EAAE,IAAI,CAAC,CAAC;QACtE,MAAM,aAAa,GAAG,gBAAgB,CAAC,MAAM,EAAE,MAAM,CAAC,SAAS,EAAE,SAAS,CAAC,CAAC;QAE5E,IAAI,OAAO,aAAa,KAAK,UAAU,EAAE;YACvC,MAAM,qBAAqB,CAAC,UAAU,EAAE,MAAM,EAAE,IAAI,EAAE,OAAO,EAAE,IAAI,CAAC,CAAC;YACrE,OAAO,aAAa,CAAC;SACtB;QAED,MAAM,iBAAiB,GAAG,aAAyB,CAAC;QAEpD,MAAM,MAAM,GAAG,gBAAgB,CAAC,iBAAiB,EAAE;YACjD,IAAI,EAAE,IAAI,IAAI,EAAE;YAChB,SAAS,EAAE,SAAS,IAAI,EAAE;YAC1B,qBAAqB,EAAE,QAAQ,CAAC,EAAE,CAChC,QAAQ,CAAC,KAAK,CAAC,MAAM,EAAE,CAAC,EAAE,MAAM,EAAE,IAAI,EAAE,OAAO,EAAE,IAAI,EAAE,CAAC,CAAC;SAC5D,CAAC,CAAC;QAEH,MAAM,MAAM,GAAG,MAAM,iBAAiB,CAAC,KAAK,CAAC,MAAM,EAAE,MAAM,CAAC,CAAC;QAE7D,MAAM,qBAAqB,CAAC,UAAU,EAAE,MAAM,EAAE,IAAI,EAAE,OAAO,EAAE,IAAI,CAAC,CAAC,CAAC,wDAAwD;QAC9H,OAAO,MAAM,CAAC;IAChB,CAAC,CAAA,CAAC;AACJ,CAAC\"}","dts":{"name":"/Users/adampietrasiak/dev/oss/typegql/domains/field/compiler/resolver.d.ts","writeByteOrderMark":false,"text":"import { GraphQLFieldResolver } from 'graphql';\r\nexport declare function compileFieldResolver(target: Function, fieldName: string): GraphQLFieldResolver<any, any>;\r\n"}}

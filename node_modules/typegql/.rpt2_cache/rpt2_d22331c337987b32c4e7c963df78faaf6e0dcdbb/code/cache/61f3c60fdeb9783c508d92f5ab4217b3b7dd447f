{"code":"import * as tslib_1 from \"tslib\";\r\nimport { injectorRegistry, } from '~/domains/inject';\r\nimport { fieldAfterHooksRegistry, fieldBeforeHooksRegistry, } from '~/domains/hooks';\r\nimport { getParameterNames } from '~/services/utils';\r\nimport { isSchemaRoot, getSchemaRootInstance } from '~/domains/schema';\r\nfunction performHooksExecution(hooks, source, args, context, info) {\r\n    return tslib_1.__awaiter(this, void 0, void 0, function () {\r\n        return tslib_1.__generator(this, function (_a) {\r\n            switch (_a.label) {\r\n                case 0:\r\n                    if (!hooks) {\r\n                        return [2 /*return*/];\r\n                    }\r\n                    return [4 /*yield*/, Promise.all(hooks.map(function (hook) {\r\n                            return hook({ source: source, args: args, context: context, info: info });\r\n                        }))];\r\n                case 1: \r\n                // all hooks are executed in parrell instead of sequence. We wait for them all to be resolved before we continue\r\n                return [2 /*return*/, _a.sent()];\r\n            }\r\n        });\r\n    });\r\n}\r\nfunction computeFinalArgs(func, _a) {\r\n    var args = _a.args, injectors = _a.injectors, injectorToValueMapper = _a.injectorToValueMapper;\r\n    var paramNames = getParameterNames(func);\r\n    return paramNames.map(function (paramName, index) {\r\n        if (args && args.hasOwnProperty(paramName)) {\r\n            return args[paramName];\r\n        }\r\n        var injector = injectors[index];\r\n        if (!injector) {\r\n            return null;\r\n        }\r\n        return injectorToValueMapper(injector);\r\n    });\r\n}\r\nfunction getFieldOfTarget(instance, prototype, fieldName) {\r\n    if (!instance) {\r\n        return prototype[fieldName];\r\n    }\r\n    var instanceField = instance[fieldName];\r\n    if (instanceField !== undefined) {\r\n        return instanceField;\r\n    }\r\n    return prototype[fieldName];\r\n}\r\nexport function compileFieldResolver(target, fieldName) {\r\n    var _this = this;\r\n    // const config = fieldsRegistry.get(target, fieldName);\r\n    var injectors = injectorRegistry.getAll(target)[fieldName];\r\n    var beforeHooks = fieldBeforeHooksRegistry.get(target, fieldName);\r\n    var afterHooks = fieldAfterHooksRegistry.get(target, fieldName);\r\n    return function (source, args, context, info) {\r\n        if (args === void 0) { args = null; }\r\n        if (context === void 0) { context = null; }\r\n        if (info === void 0) { info = null; }\r\n        return tslib_1.__awaiter(_this, void 0, void 0, function () {\r\n            var instanceField, instanceFieldFunc, params, result;\r\n            return tslib_1.__generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        if (isSchemaRoot(target)) {\r\n                            source = getSchemaRootInstance(target);\r\n                        }\r\n                        return [4 /*yield*/, performHooksExecution(beforeHooks, source, args, context, info)];\r\n                    case 1:\r\n                        _a.sent();\r\n                        instanceField = getFieldOfTarget(source, target.prototype, fieldName);\r\n                        if (!(typeof instanceField !== 'function')) return [3 /*break*/, 3];\r\n                        return [4 /*yield*/, performHooksExecution(afterHooks, source, args, context, info)];\r\n                    case 2:\r\n                        _a.sent();\r\n                        return [2 /*return*/, instanceField];\r\n                    case 3:\r\n                        instanceFieldFunc = instanceField;\r\n                        params = computeFinalArgs(instanceFieldFunc, {\r\n                            args: args || {},\r\n                            injectors: injectors || {},\r\n                            injectorToValueMapper: function (injector) {\r\n                                return injector.apply(source, [{ source: source, args: args, context: context, info: info }]);\r\n                            },\r\n                        });\r\n                        return [4 /*yield*/, instanceFieldFunc.apply(source, params)];\r\n                    case 4:\r\n                        result = _a.sent();\r\n                        return [4 /*yield*/, performHooksExecution(afterHooks, source, args, context, info)];\r\n                    case 5:\r\n                        _a.sent(); // TODO: Consider adding resolve return to hook callback\r\n                        return [2 /*return*/, result];\r\n                }\r\n            });\r\n        });\r\n    };\r\n}\r\n//# sourceMappingURL=resolver.js.map","map":"{\"version\":3,\"file\":\"resolver.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../../../src/domains/field/compiler/resolver.ts\"],\"names\":[],\"mappings\":\"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\"}"}
